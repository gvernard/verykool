#include <algorithm>
#include <string>
#include <cmath>
#include <fstream>
#include <memory>
#include <stdio.h>
#include <vector>
#include <map>
#include <valarray>

#include <fftw3.h>

#include "json/json.h"

#include "../VeryKooL/imagePlane.hpp"
#include "../VeryKooL/tableAlgebra.hpp"


void conUniCov(int ci,int cj,double* cov,double sigma){
  for(int i=0;i<ci;i++){
    for(int j=0;j<cj;j++){
      cov[j*ci+i] = sigma;
    }
  }
}

void addUniNoiz(int seed,double sigma,int Ni,int Nj,double* data){
  const double two_pi = 2.0*3.14159265358979323846;
  double z1,z2,u1,u2;
  srand48(seed);
  //  double* noiz = (double*) calloc(Ni*Nj,sizeof(double));
  
  //Applying the Box-Muller transformation
  for(int i=0;i<Ni*Nj;i++){
    u1 = drand48();
    u2 = drand48();
    z1 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
    //    z2 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);
    
    //    noiz[i] = z1*sigma;
    data[i] += z1*sigma;
  }
}



int main(int argc,char* argv[]){

  //=============== BEGIN:PARSE INPUT =======================

  //Read in the JSON input
  Json::Value root;
  if( argc > 1 ){//read json object from file
    std::ifstream fin(argv[1]);
    fin >> root;
  } else {//read json object from standard input
    std::cin >> root;
  }

  std::string output     = root["output"].asString();
  std::string imgpath    = root["imgpath"].asString();
  std::string psfpath    = root["psfpath"].asString();
  std::string noise_flag = root["noise_flag"].asString();

  //Read the noise properties as a map of strings
  std::map<std::string,std::string> noise;
  const Json::Value jnoise = root["noise"];
  noise["seed"] = jnoise["seed"].asString();
  noise["sn"]   = jnoise["sn"].asString();

  //Read the image properties as a map of strings
  std::map<std::string,std::string> image;
  const Json::Value iplane = root["iplane"];
  image["pix_x"] = iplane["pix_x"].asString();
  image["pix_y"] = iplane["pix_y"].asString();
  image["width"] = iplane["width"].asString();
  image["height"] = iplane["height"].asString();

  //Read the psf properties as a map of strings
  std::map<std::string,std::string> psf;
  const Json::Value jpsf = root["psf"];
  psf["pix_x"]  = jpsf["pix_x"].asString();
  psf["pix_y"]  = jpsf["pix_y"].asString();
  psf["crop_x"] = jpsf["crop_x"].asString();
  psf["crop_y"] = jpsf["crop_y"].asString();
  //================= END:PARSE INPUT =======================





  //=============== BEGIN:INITIALIZATION =======================
  //Read clean image data
  ImagePlane mydata(imgpath,stoi(image["pix_x"]),stoi(image["pix_y"]),stof(image["width"]),stof(image["height"]));


  //Get the maximum value of the image before any convolution
  double maxdata = *std::max_element(mydata.img,mydata.img+mydata.Ni*mydata.Nj);

  /*
  for(int i=0;i<mydata.Ni;i++){
    for(int j=0;j<mydata.Nj;j++){
      if( i<mydata.Ni/2. ){
	mydata.img[i*mydata.Nj+j] = 1;
      } else {
	mydata.img[i*mydata.Nj+j] = 0;
      }
    }
  }
  */
  //================= END:INITIALIZATION =======================





  //=============== BEGIN:PROCESS IMAGE =======================
  //Convolve image with psf
  int Ni = mydata.Ni;
  int Nj = mydata.Nj;

  if( psfpath != "0" ){
    //Read the Psf
    ImagePlane mypsf(psfpath,stoi(psf["pix_x"]),stoi(psf["pix_y"]),1.,1.);//last two arguments are dummy

    //Create psf kernel
    int Pi     = stoi(psf["pix_x"]);
    int Pj     = stoi(psf["pix_y"]);
    int Ncropx = stoi(psf["crop_x"]);
    int Ncropy = stoi(psf["crop_y"]);
    int offset = ((Pj-Ncropy)/2.)*Pi + (Pi-Ncropx)/2.;
    double* blur = (double*) calloc((Ncropx+1)*(Ncropy+1),sizeof(double));
    for(int j=0;j<Ncropy;j++){
      blur[j*(Ncropx+1)] = 0.;
      for (int i=0;i<Ncropx;i++){
	blur[j*(Ncropx+1)+i+1] = mypsf.img[offset+j*Pi+i];
	//	blur[j*(Ncropx+1)+i+1] = 0.;
      }
    }
    for (int i=0;i<Ncropx+1;i++){
      blur[Ncropy*(Ncropx+1)+i] = 0.;
    }

    /*    
    for(int j=0;j<Ncropy+1;j++){
      for (int i=0;i<Ncropx+1;i++){
	//	blur[j*(Ncropx+1)+i] = 0;
	std::cout << blur[j*(Ncropx+1)+i] << " ";
      }
      std::cout << std::endl;
    }
    */    
        
    int bNx = Ncropx/2.;
    int bNy = Ncropy/2.;
    double* kernel = (double*) calloc(mydata.Ni*mydata.Nj,sizeof(double));
    for(int j=0;j<bNy;j++){
      for(int i=0;i<bNx;i++){
	kernel[j*Ni+i]                    = blur[bNy*2*bNx+bNx+j*2*bNx+i];
	kernel[Ni-bNx+j*Ni+i]             = blur[bNy*2*bNx+j*2*bNx+i];
	kernel[Ni*(Nj-bNy)+j*Ni+i]        = blur[bNx+2*bNx*j+i];
	kernel[Ni*(Nj-bNy)+Ni-bNx+j*Ni+i] = blur[2*bNx*j+i];
      }
    }
    
    //Convolve with psf kernel
    fftw_complex* f_image  = (fftw_complex*) fftw_malloc(Ni*Nj*sizeof(fftw_complex));
    fftw_complex* f_kernel = (fftw_complex*) fftw_malloc(Ni*Nj*sizeof(fftw_complex));
    
    fftw_plan p1;
    p1 = fftw_plan_dft_r2c_2d(Ni,Nj,kernel,f_kernel,FFTW_ESTIMATE);
    fftw_execute(p1);
    fftw_destroy_plan(p1);
    
    p1 = fftw_plan_dft_r2c_2d(Ni,Nj,mydata.img,f_image,FFTW_ESTIMATE);
    fftw_execute(p1);
    fftw_destroy_plan(p1);
        
    double dum1,dum2;
    for(int i=0;i<Ni;i++) {
      for(int j=0;j<Nj;j++) {
	dum1 = f_image[i*Nj+j][0]*f_kernel[i*Nj+j][0] - f_image[i*Nj+j][1]*f_kernel[i*Nj+j][1];
	dum2 = f_image[i*Nj+j][0]*f_kernel[i*Nj+j][1] + f_image[i*Nj+j][1]*f_kernel[i*Nj+j][0];
	f_image[i*Nj+j][0] = dum1;
	f_image[i*Nj+j][1] = dum2;
      }
    }
        
    p1 = fftw_plan_dft_c2r_2d(Ni,Nj,f_image,mydata.img,FFTW_ESTIMATE);
    fftw_execute(p1);
    fftw_destroy_plan(p1);
    
    fftw_free(f_image);
    fftw_free(f_kernel);
    
    //Normalize output
    for(int i=0;i<Ni*Nj;i++){
      mydata.img[i] /= (Ni*Nj);
    }



  }

    


  //Add different kinds of noise to the image if needed
  if( noise_flag == "uniform" ){
    double sigma = maxdata/stof(noise["sn"]);
    addUniNoiz(stoi(noise["seed"]),sigma,Ni,Nj,mydata.img);
    
    std::ofstream myfile (output+"noise.dat",std::ios::out);
    myfile << sigma << std::endl;
    myfile.close();
  } else if( noise_flag == "map" ){

  } else if( noise_flag == "correlated" ){

  } else {

  }


    //Create covariance map
    //    ImagePlane mycov(Ni,Nj,1.,1.);//the last two arguments are dummy
    //    conUniCov(Ni,Nj,mycov.img,sigma);
    //Write covariance map
    //    mycov.writeFits(output+"cov.fits");

  //================= END:PROCESS IMAGE =======================





  //=============== BEGIN:OUTPUT =======================
  //Write image with added noise
  mydata.writeFits(output+"image.fits");
  //================= END:OUTPUT =======================



  return 0;
}
