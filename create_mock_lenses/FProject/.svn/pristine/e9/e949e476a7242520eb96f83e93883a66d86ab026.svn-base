#ifndef SOURCE_PROFILE_HPP
#define SOURCE_PROFILE_HPP

#include <cmath>
#include <vector>
#include <string>
#include <map>

class BaseNlpar;

class BaseProfile {
public:
  std::map<std::string,double> pars;
  int npoly = 100;
  double* x;
  double* y;
  const double pi  = 3.14159265358979323846;
  const double fac = 0.01745329251;
  
  BaseProfile(){};
  ~BaseProfile(){
    free(x);
    free(y);
    pars.clear();
  }

  virtual double value(double x,double y) = 0;

  void profile(int Sj,int Si,double* sx,double* sy,double* s){
    for(int i=0;i<Si;i++){
      for(int j=0;j<Sj;j++){
	s[i*Sj+j] += this->value(sx[i*Sj+j],sy[i*Sj+j]);
      }
    }
  }

  void ellipticalContour(){
    double dt     = (2.*this->pi)/(this->npoly);
    double cosphi = cos(this->pars["pa"]*this->fac);//in rad
    double sinphi = sin(this->pars["pa"]*this->fac);//in rad
    double size   = this->pars["r_eff"]/2.;

    for(int i=0;i<this->npoly;i++){
      this->x[i] = ( size*cos(i*dt)*cosphi - size*this->pars["q"]*sin(i*dt)*sinphi ) + this->pars["x0"];
      this->y[i] = ( size*cos(i*dt)*sinphi + size*this->pars["q"]*sin(i*dt)*cosphi ) + this->pars["y0"];
    }
  }

};
  



class Sersic: public BaseProfile {
public:
  double index;

  Sersic(std::map<std::string,BaseNlpar*> nlpars){
    this->pars["n"]     = nlpars["n"]->val;
    this->pars["r_eff"] = nlpars["r_eff"]->val;
    this->pars["i_eff"] = nlpars["i_eff"]->val;
    this->pars["q"]     = nlpars["q"]->val;
    this->pars["x0"]    = nlpars["x0"]->val;
    this->pars["y0"]    = nlpars["y0"]->val;
    this->pars["pa"]    = nlpars["pa"]->val;
    this->x = (double*) calloc(this->npoly,sizeof(double));
    this->y = (double*) calloc(this->npoly,sizeof(double));
    ellipticalContour();
  }

  double value(double x,double y){
    double bn = 1.9992*this->pars["n"] - 0.3271;//From Capaccioli 1989
    double u,v,r,fac2;
    double cosphi = cos(this->pars["pa"]*this->fac);
    double sinphi = sin(this->pars["pa"]*this->fac);

    u =   (x - this->pars["x0"])*cosphi + (y - this->pars["y0"])*sinphi;
    v = - (x - this->pars["x0"])*sinphi + (y - this->pars["y0"])*cosphi;
    r = sqrt(this->pars["q"]*this->pars["q"]*u*u + v*v);
    fac2 = pow(r/this->pars["r_eff"],1./this->pars["n"]);
    return this->pars["i_eff"]*exp(-bn*fac2 - 1);
  }
};


class Gauss: public BaseProfile {
public:
  Gauss(std::map<std::string,BaseNlpar*> nlpars){
    this->pars["r_eff"] = nlpars["r_eff"]->val;
    this->pars["i_eff"] = nlpars["i_eff"]->val;
    this->pars["q"]     = nlpars["q"]->val;
    this->pars["x0"]    = nlpars["x0"]->val;
    this->pars["y0"]    = nlpars["y0"]->val;
    this->pars["pa"]    = nlpars["pa"]->val;
    this->x = (double*) calloc(this->npoly,sizeof(double));
    this->y = (double*) calloc(this->npoly,sizeof(double));
    ellipticalContour();
  }

  double value(double x,double y){
    double u,v,r2;
    double cosphi = cos(this->pars["pa"]*this->fac);
    double sinphi = sin(this->pars["pa"]*this->fac);  
    double sdev   = 2*this->pars["r_eff"]*this->pars["r_eff"];

    u =   (x - this->pars["x0"])*cosphi + (y - this->pars["y0"])*sinphi;
    v = - (x - this->pars["x0"])*sinphi + (y - this->pars["y0"])*cosphi;
    r2 = (this->pars["q"]*this->pars["q"]*u*u + v*v)/sdev;
    //    return (this->ieff*exp(-r2)/(sqrt(sdev*3.14159)));
    return this->pars["i_eff"]*exp(-r2);
  }
};



class FactoryProfile{//This is a singleton class.
public:
  FactoryProfile(FactoryProfile const&) = delete;//Stop the compiler generating methods of copy the object.
  void operator=(FactoryProfile const&) = delete;

  static FactoryProfile* getInstance(){
    static FactoryProfile dum;//Guaranteed to be destroyed. Instantiated on first call.
    return &dum;
  }

  BaseProfile* createProfile(const std::string &modelname,std::map<std::string,BaseNlpar*> nlpars){
    if( modelname == "sersic" ){
      return new Sersic(nlpars);
    } else if ( modelname == "gauss" ){
      return new Gauss(nlpars);
    } else {
      return NULL;
    }
  }

private:
  FactoryProfile(){};
};

#endif /* SOURCE_PROFILE_HPP */
