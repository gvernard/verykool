#include "pixposFuncs.hpp"


void centralPixel(int Ni,int Nj,double Li,double Lj,double* x,double* y,int* i0_out,int* j0_out){
  int i0 = floor(Ni/2);
  int j0 = floor(Nj/2);
  //  std::cout << i0 << " " << j0 << std::endl;

  double di = Li/(Ni-1);
  double dj = Lj/(Nj-1);
  //  std::cout << di << " " << dj << std::endl;


  for(int i=0;i<Ni;i++){
    for(int j=0;j<Nj;j++){
      x[i*Nj+j] = (j-j0)*dj;
      y[i*Nj+j] = -(i-i0)*di;//reflect y-axis
    }
  }

  *i0_out = i0;
  *j0_out = j0;

  /*
  std::cout << x[i0*Ni+j0] << " " << y[i0*Ni+j0] << std::endl;

  std::cout << x[0] << " " << y[0] << std::endl;
  std::cout << x[Nj-1] << " " << y[Nj-1] << std::endl;
  std::cout << x[Ni*(Nj-1)] << " " << y[Ni*(Nj-1)] << std::endl;
  std::cout << x[Ni*Nj-1] << " " << y[Ni*Nj-1] << std::endl;
  */
}

void maxCorners(double b,double q,double par,double xl,double yl,double* ix,double* iy,int Ni,int Nj,double* sxmax,double* sxmin,double* symax,double* symin){
  //pixel locations of the image corners
  double xcor[4];
  double ycor[4];
  sis_defl(b,q,par,xl,yl,ix[0],iy[0],xcor,ycor);
  sis_defl(b,q,par,xl,yl,ix[Nj-1],iy[Nj-1],xcor+1,ycor+1);
  sis_defl(b,q,par,xl,yl,ix[Ni*(Nj-1)],iy[Ni*(Nj-1)],xcor+2,ycor+2);
  sis_defl(b,q,par,xl,yl,ix[Ni*Nj-1],iy[Ni*Nj-1],xcor+3,ycor+3);

  double xmax = *std::max_element(xcor,xcor+4);
  double xmin = *std::min_element(xcor,xcor+4);
  double ymax = *std::max_element(ycor,ycor+4);
  double ymin = *std::min_element(ycor,ycor+4);


  //output deflected image grid corners
  FILE* ptr_myfile = fopen("corners_source.dat","w");
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[0],ycor[0]);
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[1],ycor[1]);
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[2],ycor[2]);
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[3],ycor[3]);
  fclose(ptr_myfile);


  double max=0,min=0;
  if( xmax > ymax ){
    max = xmax;
  } else {
    max = ymax;
  }
  if( xmin < ymin ){
    min = xmin;
  } else {
    min = ymin;
  }
  *sxmax = max;
  *symax = max;
  *sxmin = min;
  *symin = min;

}

void fixedGrid(double d,double* sxmax,double* sxmin,double* symax,double* symin,double sx0,double sy0){
  *sxmax = sx0 + d;
  *sxmin = sx0 - d;
  *symax = sy0 + d;
  *symin = sy0 - d;
}



void gridSourcePixels(int Si,int Sj,double sxmax,double sxmin,double symax,double symin,double* sx,double* sy){
  double dsx = (sxmax - sxmin)/Sj;
  double dsy = (symax - symin)/Si;

  for(int i=0;i<Si;i++){
    for(int j=0;j<Sj;j++){
      sx[i*Sj+j] = sxmin + j*dsx;
      sy[i*Sj+j] = symin + i*dsy;
    }
  }

}




void gaussian(int Sj,int Si,double* sx,double* sy,double* s,double size){
  double sdevx = size;
  double sdevy = size;

  double u,v;
  double dumx = 2*sdevx*sdevx;
  double dumy = 2*sdevy*sdevy;


  for(int i=0;i<Si;i++){
    for(int j=0;j<Sj;j++){
      u = sx[i*Sj+j];
      v = sy[i*Sj+j];
      s[i*Sj+j] = exp(-u*u/dumx-v*v/dumy);
    }
  }

}

double boxMuller(double mean,double sigma){

  const double two_pi = 2.0*3.14159265358979323846;
  double z1,z2;
  srand48(123);

  double u1,u2;
  //do {
  u1 = drand48();
  u2 = drand48();
  //} while ( u1 <= epsilon );

  z1 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
  z2 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);
  return z1*sigma + mean;
}
