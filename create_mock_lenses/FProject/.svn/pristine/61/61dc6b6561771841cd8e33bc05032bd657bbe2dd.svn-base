#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <png.h>
#include <fstream>
#include <algorithm>

#include "massModelFuncs.hpp"


void centralPixel(int Ni,int Nj,double Li,double Lj,double* x,double* y,int* i0_out,int* j0_out){
  int i0 = floor(Ni/2);
  int j0 = floor(Nj/2);
  //  std::cout << i0 << " " << j0 << std::endl;

  double di = Li/(Ni-1);
  double dj = Lj/(Nj-1);
  //  std::cout << di << " " << dj << std::endl;


  for(int i=0;i<Ni;i++){
    for(int j=0;j<Nj;j++){
      x[i*Nj+j] = (j-j0)*dj;
      y[i*Nj+j] = -(i-i0)*di;//reflect y-axis
    }
  }

  *i0_out = i0;
  *j0_out = j0;

  /*
  std::cout << x[i0*Ni+j0] << " " << y[i0*Ni+j0] << std::endl;

  std::cout << x[0] << " " << y[0] << std::endl;
  std::cout << x[Nj-1] << " " << y[Nj-1] << std::endl;
  std::cout << x[Ni*(Nj-1)] << " " << y[Ni*(Nj-1)] << std::endl;
  std::cout << x[Ni*Nj-1] << " " << y[Ni*Nj-1] << std::endl;
  */
}

void maxCorners(double b,double q,double par,double xl,double yl,double* ix,double* iy,int Ni,int Nj,double* sxmax,double* sxmin,double* symax,double* symin){
  //pixel locations of the image corners
  double xcor[4];
  double ycor[4];
  sis_defl(b,q,par,xl,yl,ix[0],iy[0],xcor,ycor);
  sis_defl(b,q,par,xl,yl,ix[Nj-1],iy[Nj-1],xcor+1,ycor+1);
  sis_defl(b,q,par,xl,yl,ix[Ni*(Nj-1)],iy[Ni*(Nj-1)],xcor+2,ycor+2);
  sis_defl(b,q,par,xl,yl,ix[Ni*Nj-1],iy[Ni*Nj-1],xcor+3,ycor+3);

  double xmax = *std::max_element(xcor,xcor+4);
  double xmin = *std::min_element(xcor,xcor+4);
  double ymax = *std::max_element(ycor,ycor+4);
  double ymin = *std::min_element(ycor,ycor+4);


  //output deflected image grid corners
  FILE* ptr_myfile = fopen("corners_source.dat","w");
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[0],ycor[0]);
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[1],ycor[1]);
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[2],ycor[2]);
  fprintf(ptr_myfile,"%7.4f,%7.4f\n",xcor[3],ycor[3]);
  fclose(ptr_myfile);


  double max=0,min=0;
  if( xmax > ymax ){
    max = xmax;
  } else {
    max = ymax;
  }
  if( xmin < ymin ){
    min = xmin;
  } else {
    min = ymin;
  }
  *sxmax = max;
  *symax = max;
  *sxmin = min;
  *symin = min;

}

void fixedGrid(double d,double* sxmax,double* sxmin,double* symax,double* symin){
  *sxmax = d;
  *sxmin = -d;
  *symax = d;
  *symin = -d;
}



void gridSourcePixels(int Si,int Sj,double sxmax,double sxmin,double symax,double symin,double* sx,double* sy){
  double dsx = (sxmax - sxmin)/Sj;
  double dsy = (symax - symin)/Si;

  for(int i=0;i<Si;i++){
    for(int j=0;j<Sj;j++){
      sx[i*Sj+j] = sxmin + j*dsx;
      sy[i*Sj+j] = symin + i*dsy;
    }
  }

}




void gaussian(int Sj,int Si,double* sx,double* sy,double* s,double sxmax){
  double sdevx = sxmax/3.;
  double sdevy = sxmax/3.;

  double u,v;
  double dumx = 2*sdevx*sdevx;
  double dumy = 2*sdevy*sdevy;


  for(int i=0;i<Si;i++){
    for(int j=0;j<Sj;j++){
      u = sx[i*Sj+j];
      v = sy[i*Sj+j];
      s[i*Sj+j] = exp(-u*u/dumx-v*v/dumy);
    }
  }

}




double maximumValue(int size,double* array){
     double max = array[0];

     for(int i = 1; i<size; i++){
       if(array[i] > max){
	 max = array[i];
       }
     }
     return max;
}
double minimumValue(int size,double* array){
     double min = array[0];

     for(int i = 1; i<size; i++){
       if(array[i] < min){
	 min = array[i];
       }
     }
     return min;
}

void writeArrayPng(const char* filename, int width, int height, double* buffer){

   FILE* fp = fopen(filename, "wb");
   png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
   png_infop info_ptr  = png_create_info_struct(png_ptr);
   png_bytep row;


   png_init_io(png_ptr, fp);
   png_set_IHDR(png_ptr, info_ptr, width, height, 8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
   png_write_info(png_ptr, info_ptr);


   double min = minimumValue(width*height,buffer);
   double max = maximumValue(width*height,buffer);

   std::cout << min << " " << max << std::endl;

   double factor = 255./(fabs(min)+max);
   double dum;
   


   //Write RGB values to image
   row = (png_bytep) malloc(3 * width * sizeof(png_byte));
   int i, j;
   int v;
   for (j=height-1;j>=0;j--) {
      for (i=0;i<width;i++) {

	dum = (buffer[j*width+i] + fabs(min))*factor;
	v = (int) dum;

	row[i*3]   = v;
	row[i*3+1] = v;
	row[i*3+2] = v;
      }
      png_write_row(png_ptr, row);
   }

   png_write_end(png_ptr, NULL);



   fclose(fp);
   png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
   png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
   free(row);
}

double boxMuller(double mean,double sigma){

  const double two_pi = 2.0*3.14159265358979323846;
  double z1,z2;
  srand48(123);

  double u1,u2;
  //do {
  u1 = drand48();
  u2 = drand48();
  //} while ( u1 <= epsilon );

  z1 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
  z2 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);
  return z1*sigma + mean;
}
