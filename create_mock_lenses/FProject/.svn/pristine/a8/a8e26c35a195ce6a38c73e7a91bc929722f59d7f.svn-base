#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <fstream>
#include <Eigen/Dense>
#include <png.h>
#include <string>

#include "imgFuncs.hpp"

#include "pixposFuncs.hpp"
#include "massModelFuncs.hpp"
#include "initFuncs.hpp"


using std::cout;
using std::endl;
using std::string;



int main(int argc,char* argv[]){

  params p;
  if ( setParams(argc,argv,p) ){//if successfull, setParams has already set the parameters.
    return -1;
  }



  //=============== BEGIN:INITIALIZATION =======================
  //Read/set image size
  int Ni = p.pixw;
  int Nj = p.pixh;
  double Li = p.w;
  double Lj = p.h;
  printf("%+30s%3d%1s%-3d%2s%d%-20s\n","Image dimensions: ",Ni,"x",Nj," (",Ni*Nj,") pixels.");
  printf("%+30s%5.3f%1s%-5.3f%-20s\n","Image dimensions: ",Li,"x",Lj," arcsec.");

  //Read/set image pixel values
  double* data = (double*) calloc(Ni*Nj,sizeof(double));

  double* ix = (double*) calloc(Ni*Nj,sizeof(double));
  double* iy = (double*) calloc(Ni*Nj,sizeof(double));
  int i0,j0;
  centralPixel(Ni,Nj,Li,Lj,ix,iy,&i0,&j0);




  //initialize mass model
  double b   = p.b;  //Einstein radius
  double q   = p.q; //axis ratio (y/x)
  double pa  = p.pa; //position angle (degrees)
  double par = pa*3.14159/180.;//position angle (radians)
  double xl  = p.xl;  //abscissa of the lens center
  double yl  = p.yl;  //ordinate of the lens center




  //initialize source grid
  int Si = 30;
  int Sj = 30;
  double sxmax,sxmin,symax,symin;
  fixedGrid(p.s*3.,&sxmax,&sxmin,&symax,&symin,p.xs,p.ys);

  double* sx = (double*) calloc(Si*Sj,sizeof(double));
  double* sy = (double*) calloc(Si*Sj,sizeof(double));
  gridSourcePixels(Si,Sj,sxmax,sxmin,symax,symin,sx,sy);

  //set a fixed source
  double* s = (double*) calloc(Si*Sj,sizeof(double));
  gaussian(Sj,Si,sx,sy,s,p.s);
  //================= END:INITIALIZATION =======================







  //=============== BEGIN:DEFINE L MATRIX/RAY-SHOOTING ==========================
  int ic=0,jc=0;
  double g1,g2,g3,g4;
  long excluded = 0;
  double xdefl=0,ydefl=0;
  double dsx = (sxmax - sxmin)/Sj;
  double dsy = (symax - symin)/Si;

  double* L = (double*) calloc(Ni*Nj*Si*Sj,sizeof(double));





  for(int i=0;i<Ni;i++){
    for(int j=0;j<Nj;j++){

      sis_defl(b,q,par,xl,yl,ix[i*Nj+j],iy[i*Nj+j],&xdefl,&ydefl);

      if( xdefl <= sxmin || xdefl >= sxmax || ydefl <= symin || ydefl >= symax ){
	excluded++;
      } else {


	//Indices corresponding to the top left pixel
	ic = (int) floor((ydefl - symin)/dsy);
	jc = (int) floor((xdefl - sxmin)/dsx);



	//Now interpolate between neighbouring pixels and add entries to L matrix.
	//The interpolation function could return an array of column indices in the row of the L matrix, and the corresponding weights.
	//The following is for bi-linear interpolation:
	g1 = (ic+1)*dsy - (ydefl - symin);
	g2 = (jc+1)*dsx - (xdefl - sxmin);
	g3 = (ydefl - symin) - ic*dsy;
	g4 = (xdefl - sxmin) - jc*dsx;


	L[(i*Nj+j)*Sj*Si + (ic*Sj+jc)] = g1*g2;
	L[(i*Nj+j)*Sj*Si + (ic*Sj+jc+1)] = g1*g4;
	L[(i*Nj+j)*Sj*Si + ((ic+1)*Sj+jc)] = g3*g2;
	L[(i*Nj+j)*Sj*Si + ((ic+1)*Sj+jc+1)] = g3*g4;

      }

 
    }
  }


  cout << excluded << " image pixels lie outside the source grid." << endl;
  //================= END:DEFINE L MATRIX/RAY-SHOOTING ==========================









  double* img = (double*) calloc(Ni*Nj,sizeof(double));
  for(int i=0;i<Ni*Nj;i++){

    img[i] = 0;
    for(int j=0;j<Si*Sj;j++){
      img[i] += L[i*(Si*Sj)+j] * s[j];
    }
    
  }




  //  string srcname = "source.png";
  //  writeArrayPng(srcname.data(),Sj,Si,s);

  string imgname = p.target_dir + "image.png";
  writeArrayPng(imgname.data(),Nj,Ni,img);

  string binname = p.target_dir + "data.bin";  
  std::ofstream out(binname.data(),std::ios::out|std::ios::binary);
  for(int i=0;i<Ni;i++){
    for(int j=0;j<Nj;j++){
      out.write((const char*) (&img[i*Nj+j]),sizeof(double));
    }
  }
  out.close();



  /*
  //Add Noise to the image

  double smax = 0.;
  for(int i=0;i<Ni*Nj;i++){
    if( img[i] > smax ){
      smax = img[i];
    }
  }

  cout << " maximum signal: " << smax << endl;


  const double two_pi = 2.0*3.14159265358979323846;
  double z1,z2,u1,u2;
  srand48(123);
  double* noiz = (double*) calloc(Ni*Nj,sizeof(double));

  for(int i=0;i<Ni*Nj;i++){
    u1 = drand48();
    u2 = drand48();
    z1 = sqrt(-2.0 * log(u1)) * cos(two_pi * u2);
    z2 = sqrt(-2.0 * log(u1)) * sin(two_pi * u2);

    noiz[i] = z1*smax/10.;
    img[i] += noiz[i];
  }

  string noizname = p.target_dir + "image_noiz.png";
  writeArrayPng(noizname.data(),Nj,Ni,img);
  */

  //----------------------------------------------------------




  return 0;
}
